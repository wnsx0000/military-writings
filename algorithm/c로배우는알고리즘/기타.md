작성자: jhun0310 (wnsx0000@gmail.com)<br>
출처: 이재규. c로 배우는 알고리즘 1. 도서출판 세화, 1994.

22\. 10\. 22\. 최초 작성.

<br>
<br>

# 1. 기타 알고리즘들

### a la russe

> 두 자연수의 곱셈에 대한 알고리즘.
>
> 방식은 아래와 같음.<br>
> 1. 두 정수를 첫번째, 두번째 위치에 놓는다. 첫번째 수가 홀수이면 두번째 수를 세번째 위치에 또 놓고, 짝수이면 비워둔다.
> 2. 첫번째 수를 2로 나누고(나머지는 버린다.), 두번째 수에 2를 곱한다. 
> 3. 1번과 2번을 첫번째 수가 1이 될 때까지 반복한다.
> 4. 세번째 위치에 있는 수들을 모두 더한 것이 두 정수의 곱이다.

### 유클리드의 최대공약수 찾기

> 최대공약수의 성질.
> 1. A와 B의 최대공약수는 A와 (A - B)의 최대공약수와 같다.[^1-1]
> 2. A와 0의 최대공약수는 A이다.
>
> 위 성질을 이용해 두 수를 서로 빼(나누어)가며 간단하게 최대공약수를 구할 수 있음.

### 최단 경로 찾기(중복되는 부분 제거)

> 우선법(right hand on wall)을 사용해서 미로를 통과한다면, 잘못된 길로 들어선 경우에는 반드시 자신이 지나온 부분을 다시 지나게 됨.<br>
> 경로에서 좌표가 같아지는 경우를 발견하면, 두 좌표 사이를 삭제함으로서 최단 경로를 찾을 수 있음.


<br>
<br>
<br>

# 2. 코드 작성 팁들

### 2의 거듭제곱과 | 연산자를 이용한 경우 쪼개기

> 2의 거듭제곱수는 이진수로 나타내었을 때 하나의 1과 다수의 0으로 이루어져 있음.<br>
> 그러므로 2의 거듭제곱수들을 비트 연산자 |(OR)로 연산하면 각 조합에 따른 유일한 정수를 얻을 수 있어, 경우를 나누기에 용이함.

> ex.<br>
> ``` c
> #define UP    1
> #define RIGHT 2
> #define DOWN  4
> #define LEFT  8
> ```
> 위처럼 매크로를 만든 경우 UP | RIGHT | DOWN 은 7, DOWN | LEFT 는 12 등으로, 각 조합에 따른 유일한 정수를 얻을 수 있음.<br>

### 배열 사용 시 Stack Overflow 방지

> 배열의 요소에 접근할 때는 조건문을 걸어 할당되지 않은 메모리를 건드릴 수 없게 하는 것이 좋음.

### 2의 연산

> 2를 곱하거나 나눌 때는 `>>` 연산자와 `<<` 연산자를 사용하는 것이 좋음.

### 정적 지역변수의 활용

> 해당 함수 내에서만 사용하거나, 값을 반납하지 않는 변수에 대한 경우 등에서 static의 사용을 적극적으로 고려하자.

### 조건문과 ? 연산자

> 긴 조건문은 ? 연산자(삼항 연산자, 조건 연산자)로 대체하는 것도 고려해 보자.

### 반복되는 부분 통일하기

> 반복적으로 사용되는 작업을 함수로 작성해두거나, 여러 군데에서 사용되는 값을 상수로 만드는 것 등은 코드를 짜임새 있도록 함.



[^1-1]: A = a * G, B = b * G, A - B = (a - b) * G 이기 때문.
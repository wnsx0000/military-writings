작성자: jhun0310 (wnsx0000@gmail.com)<br>
출처: 이재규. c로 배우는 알고리즘 1. 도서출판 세화, 2021.

22\. 10\. 22\. 최초 작성.

<br>

### 목차
1. 알고리즘
2. 알고리즘의 분석

<br>
<br>

# 1. 알고리즘

### 1) 알고리즘

> ***"알고리즘이란 주어진 문제를 해결하기 위한 잘 정의된 동작들의 유한 집합이다."***

### 2) 알고리즘의 선택

> 절대적으로 최상의 알고리즘은 존재하지 않기 때문에, 개발자는 문제를 잘 이해하고 메모리, 속도, 안정성 등을 고려하여 분석한 후 적절한 알고리즘을 선택해야 함.
>
> 일반적으로 속도보다는 단순함을 추구하는 것이 좋음.[^1-1]<br>
> 1. 최초로 문제에 부딪혔을 때는 가장 단순한 알고리즘을 사용하는 것이 좋음. 일단 만들어 보고, 이후에 개선하는 것.[^1-2]
> 2. 사용 빈도가 낮은 코드는 효율성보다 단순함을 우선하는 것이 좋음.

### 3) 자료구조와 알고리즘

> '무엇을 어떻게 해라'에서 '무엇'이 자료이고, '어떻게 해라'가 알고리즘임.<br>
>
> 기본적으로 알고리즘의 복잡도와 해당 자료구조의 복잡도는 반비례함.[^1-3]<br>
>
> 자료구조가 행위적 측면을 포함할 때 이것을 추상 자료형(ADT)이라 함.<br>
> 추상 자료형은 복잡하지만, 이때의 알고리즘은 단순한 형태를 가짐.

<br>
<br>

# 2. 알고리즘의 분석

### 1) 알고리즘 분석의 종류

> 알고리즘 분석은 경험적 분석과 수학적 분석으로 나눌 수 있음.
>
> 경험적 분석 : 알고리즘을 프로그램으로 구현한 뒤 실행 시간을 측정하여 분석하는 방식.<br>
> 수학적 분석 : 알고리즘을 프로그램으로 구현하지 않고 수학적으로 분석하는 방식.[^2-1]

### 2) 최악의 경우와 최선의 경우

> 하나의 알고리즘에 대하여 여러 경우를 관측해 보면 최선/최악의 경우가 존재함.
>
> 최악의 경우 : 해당 알고리즘을 수행하는 데에 가장 많은 시간/공간을 필요로 하는 경우.<br>
> 최선의 경우 : 해당 알고리즘을 수행하는 데에 가장 적은 시간/공간을 필요로 하는 경우.<br>
> 평균적 경우[^2-2] : 평균적인 시간/공간을 필요로 하는 경우.
>
> 알고리즘의 성능을 나타낼 때는 최악의 경우(O 표기법)에 한하는 것이 기본임.

### 3) 알고리즘 분석의 단계

> 알고리즘 분석은 3개의 단계로 이루어짐.
>
> 1. 알고리즘을 분석하는 데에 사용할 입력 자료를 결정한다.
> 2. 알고리즘을 부분 동작들로 분해하여 각 동장들의 수행 시간을 계산해 본다.
> 3. 수학적으로 알고리즘을 분석한다.
>
> 원하는 정도의 결과가 나올 때까지 분석, 측정, 개선하는 것.

### 4) 알고리즘의 유형

> 알고리즘 분석의 결과는 입력 자료의 수 N에 대한 수행 시간을 함수로 표현한 것임. <br>
> 해당 함수를 통해 알고리즘을 유형화할 수 있음.
>
> 실제 함수는 아래의 유형에 상수가 곱해지고 더해진 형태를 가짐.[^2-3]
> 
> - 1
>
>   대부분의 명령들이 굉장히 적은 횟수로 시행될 때 나타나는 유형.
>
> - log N
>
>   큰 문제를 일정 크기의 작은 문제로 나누었을 때 나타나는 유형.<br>
>   성능이 좋은 검색 알고리즘에서 주로 확인할 수 있음.
>
> - N
>
>   입력 자료 각각에 대해 동일한 처리를 할 때 나타나는 유형.<br>
>   준수한 성능인 것으로 판단할 수 있음.
>
> - N log N
>
>   큰 문제를 작은 문제로 나누고, 각각에 대해 독립적으로 해결했을 때 나타나는 유형.<br>
>   성능이 좋은 정렬 알고리즘에서 주로 확인할 수 있음.
>
> - N^2
>
>   입력 자료를 이중 루프로 처리할 때 나타나는 유형.<br>
>   많은 양의 입력 자료에 대해서는 사용이 부적절함.
>
> - N^3
>
>   입력 자료를 이중 루프로 처리할 때 나타나는 유형.<br>
>   많은 양의 입력 자료에 대해서는 사용이 부적절함.
>
> - 2^N
>
>   흔하지 않으며, 알고리즘을 처음 개발할 때 주로 나타나는 유형.<br>

<img src="https://t1.daumcdn.net/cfile/tistory/25047340590B923732" width="300" height="300" />

### 5) 성능 표기법

> 알고리즘의 성능을 객관적으로 표현하기 위한 방식들.<br>
> 상수를 제거하여 해당 알고리즘이 가지는 유형의 원형을 확인하는 것.
>
> 시간 소요량뿐만 아니라, 공간 소요량도 아래의 표기법으로 나타낼 수 있음.[^2-4]
>
> - O 표기법(Big-Oh notation)
>
>   > ***"N >= N0인 모든 N에 대하여 T(N) <= C0f(N)이 만족하면 T(N) = O(f(N))이다."***
>   >
>   > (N0: 0보다 큰 정수, T(N): 실제의 실행 시간 함수, N: 입력 자료의 수, C0: 상수, f(N): 알고리즘의 유형)
>
>   O 표기법은 그 개념상 실행 시간의 상한선, 즉 최악의 경우를 나타냄.
>
>   일반적으로 T(N)이 N에 대한 다항식일 때는 최고차항만 살피면 됨.
>
>   O 표기법은 최악의 경우를 나타내기에 실제 성능과는 차이가 있을 수 있고, C0와 N0이 충분히 작을 때에만 유효하다는 유의점이 있음.
>
> <br>
>
> - Ω(오메가) 표기법
>
>   > ***"N >= N0인 모든 N에 대하여 T(N) >= C0f(N)이 만족하면 T(N) = Ω(f(N))이다."***
>   >
>   > (N0: 0보다 큰 정수, T(N): 실제의 실행 시간 함수, N: 입력 자료의 수, C0: 상수, f(N): 알고리즘의 유형)
>
>   Ω 표기법은 그 개념상 실행 시간의 하한선, 즉 최선의 경우를 나타냄.
>
> <br>
>
> - Θ(세타) 표기법
>
>   > ***"N >= N0인 모든 N에 대하여 C1f(N) <= T(N) <= C2f(N)이 만족하면 T(N) = Θ(f(N))이다."***
>   >
>   > (N0: 0보다 큰 정수, T(N): 실제의 실행 시간 함수, N: 입력 자료의 수, C1: 상수, C2: 상수, f(N): 알고리즘의 유형)
>
>   Θ 표기법은 알고리즘의 성능을 정확히 나타냄.

<br>
<br>
<br>

[^1-1]: '속도 결벽증'에 빠지지 않도록 하자.
[^1-2]: 프로그래머의 정신건강 상에도 좋고, 일단 만들어 보면 효율적인 개선을 이뤄낼 수 있음.
[^1-3]: 자료구조\-알고리즘은 계란 안의 노른자\-흰자와 같음.
[^2-1]: 수학적 분석은 비교적 복잡하지만, 프로그래머의 능력에 따라 나타나는 편차를 배제한 채 분석할 수 있다는 장점이 있음.
[^2-2]: 평균적 경우는 수학적으로 확정짓기 어렵고, 확률적인 값이기 때문에 실제로 가장 많이 입력되는 값을 나타내지는 못한다는 단점이 있음.
[^2-3]: 효율성 있게 코드를 짜더라도 상수값이 달라질 뿐, 알고리즘의 유형이 바뀌지는 않음. 획기적인 시/공간적 개선을 위해서는 알고리즘 자체를 수정해서 그 유형을 바꾸어야 함.
[^2-4]: 일반적으로 한 프로그램에 대한 시간 소요량과 공간 소요량은 반비례하는데, 대체로 시간 소요량이 훨씬 중요하게 취급됨.
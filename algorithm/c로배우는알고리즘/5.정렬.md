작성자: jhun0310 (wnsx0000@gmail.com)<br>
출처: 이재규. c로 배우는 알고리즘 1. 도서출판 세화, 1994.

22\. 12\. 11\. 최초 작성.

### 목차
1. 정렬

<br>
<br>

# 1. 정렬(Sort)

### 1) 정렬(Sort)

> ***"임의의 순서로 배열된 자료의 집합을 일정 순서로 재배열하는 것."***

> 검색과 함께 가장 많이 사용/연구되는 알고리즘 중 하나임.<br>
> 다양한 종류의 알고리즘이 존재하기 때문에 적절한 선택이 필요.

### 2) 정렬의 방법론

> 정렬의 과정은 '판단(decision)'과 '교환(exchange)'으로 이루어짐.<br>
> 즉 정렬 알고리즘은 판단과 교환을 어떻게 적절히 조합하는가에 대한 방법론임.

### 3) 정렬 관련 용어들

> 파일(file) : 정렬을 실시하는 데이터의 집합.<br>
> 레코드(record) : 파일 속 각 데이터 요소들. -> 일반 변수, 구조체 등.<br>
> 필드(field) : 레코드의 정보를 담고 있는 세부 요소들. -> 구초제 멤버 등.<br>
> 키(key) : 정렬 시 판단의 기준이 되는 요소들.
>
> 비교의 대상이 되는 것은 레코드 내의 키(필드 중 하나) 값이고, 교환의 대상이 되는 것은 레코드 자체임.

### 4) 정렬의 분류

> 1. 간단한 vs. 복잡한<br>
>   간단한 정렬 알고리즘: 안정적, 구현 쉬움, 느림. (선택, 삽입, 거품, 셀)<br>
>   복잡합 정렬 알고리즘: 구현 어려움, 추가 메모리 필요, 빠름. (퀵, 기수, 힙, 병합)
>
> 2. 내부 vs. 외부<br>
>   내부 정렬(internal): 레코드의 집합이 메모리에 있음. 빠름, 데이터를 전부 메모리에 올려야 함.<br>
>   외부 정렬(external): 레코드의 집합이 디스크 등에 있음. 느림, 메모리 차지 안함.
>
> 3. 직접 vs. 간접<br>
>   직접 정렬(direct): 교환 시 레코드 전체 교환. 메모리 절약(포인터X), 데이터 복사로 인한 시간 지연.<br>
>   간접 정렬(indirect): 교환 시 포인터만 교환. 메모리 소요, 속도 향상.
>
> 4. 삽입 vs. 교환 vs. 병합 vs. 선택 vs. 세기 (정렬 기본 방법에 따른 분류)<br>
>   삽입(insertion): 삽입, 쉘.<br>
>   교환(exchange): 거품, 퀵.<br>
>   병합(merge): 병합.<br>
>   선택(selection): 선택, 힙.<br>
>   세기(counting): 분포수세기, 직접 기수.

### 5) 다중 키(multi-key) 정렬

> ***"여러 개의 키를 사용하는 정렬."***

> 우선순위가 높은 키를 적용하여 정렬한 후, 동일한 키 값을 가진 레코드들에 대해서는 다음 우선순위의 키를 사용하여 배열하는 것.<br>
> 가장 우선순위가 높은 키를 일차 키(primary key), 그 다음 키를 2차 키(secondary key) 등으로 부름.

### 6) 정렬의 안정성(stability)

> ***"동일한 키 값을 가지는 레코드들이 정렬 후에도 상대적 순서가 유지되는지에 대한 성질."***
>
> 여러 번의 정렬을 진행할 때, 해당 정렬이 이전 정렬에서 배열된 순서를 바꾸어 놓지 않을수록 안정성 있는 정렬이라고 함.('c로배우는알고리즘1' p.320 참고.)

### 7) 정렬의 실행 시간 분석

> 최악의 경우, 최선의 경우, 평균적인 경우는 이미 정렬된 배열, 난수의 배열, 반 정도 정렬된 배열, 역순의 배열에서 찾을 수 있는 경우가 많음.

### 8) 정렬의 일반화

> 데이터의 자료형에 따라 함수를 만들고 사용하는 것은 불편하므로 일반화시키는 것이 좋음.<br>
> void 포인터와, char형 포인터를 이용한 메모리 접근[^1-1], 함수 포인터로 간단히 일반화할 수 있음.<br>
> memcpy() 함수는 22.12.17. 기준 string.h에 있음.
> 
> 데이터 저장 변수 int min ---> void *min; min = malloc(ele_size);<br>
> 배열 요소 &(a[i]) ---> (char*)a + (ele_num * ele_size)<br>
> 대소 비교 min > a[i] ---> cmp(min, (char *)a + (ele_num * ele_size)) > 0<br>
> a[i] = min ---> memcpy((char *)a + (ele_num * ele_size), min, width);

```c
//선택 정렬을 이용한 예시.

/*
d1>d2이면 양수, d1==d2이면 0, d1<d2이면 음수 리턴.(int형 정수의 오름차순 정렬.)
*/
int cmp_int(void *d1, void *d2)
{
    return (*((int *)d1) - *((int *)d2));
}

/*
선택 정렬로 배열을 cmp 함수 포인터에 들어오는 함수에 따라서 정렬하는 일반형 함수.
ele_num->요소 개수
ele_size->요소 크기
(레코드가 문자열인 경우(a에 이차원 포인터) 등에 대해선 적용되지 않음.)
*/
void selection_sort_jen(void *a, int ele_num, int ele_size, int (*cmp)(void *d1, void *d2))
{
    int min;
    void *tmp = malloc(ele_size);
    for(int i = 0; i < ele_num; i++)
    {
        min = i;
        for(int j = (i + 1); j < ele_num; j++)
        {
            if(cmp((char *)a + (ele_size * min), (char *)a + (ele_size * j)) > 0) //a[min] > a[j], 비교
            {
                min = j;
            }
        }
        
        if(min != i)
        {
            //a[min] <-> a[i], 교환
            memcpy(tmp, (char *)a + (ele_size * min), ele_size);
            memcpy((char *)a + (ele_size * min), (char *)a + (ele_size * i), ele_size);
            memcpy((char *)a + (ele_size * i), tmp, ele_size);
        }
    }
    return;
}
```

<br>
<br>
<br>

# 2. 선택 정렬(selection sort)

### 1) 선택 정렬(selection sort)

> ***"한쪽에서부터 시작하여 각 레코드에 대해서, 아직 서로 비교된 적 없는 모든 레코드와 비교를 진행한 후 순서에 맞게 서로 교환하는 방식."***

> 많은 비교와 적은 교환을 함.<br>
> 데이터의 수를 N이라고 할 때, 비교 횟수는 N^2 정도이지만, 교환 횟수는 N 정도임.[^2-3]
>
> 가장 간단하고 자주 사용되는 정렬 알고리즘임.
>
> 파일의 한쪽 부분부터 차례대로 정렬함.
>
> 이중 루프를 사용하기 때문에 O(N^2)의 성능을 가짐.

### 2) 장점

> 1. 크기가 큰 레코드를 정렬할 때 효과적임.(레코드의 크기에 구애받지 않음.)[^2-1]

### 3) 단점

> 1. 자료의 개수가 커질수록 실행 속도가 급격히 늘어남.
> 2. 안정성이 없음.[^2-2]

### 4) 예시
```c
/*
선택 정렬로 정수 배열을 오름차순으로 정렬하는 함수.
*/
void selection_sort(int a[], int size)
{
    int min, tmp;
    for(int i = 0; i < size; i++)
    {
        min = i;
        for(int j = (i + 1); j < size; j++)
        {
            if(a[min] > a[j]) //비교
            {
                min = j;
            }
        }
        
        if(min != i) //교환
        {
            tmp = a[min];
            a[min] = a[i];
            a[i] = tmp;
        }
    }
    return;
}
```

<br>
<br>
<br>

# 3. 삽입 정렬(insertion sort)

### 1) 삽입 정렬(insertion sort)

> ***"한쪽(a)에서부터 시작하여 a로부터 각 레코드(A)에 대해, a쪽으로 레코드끼리 서로 비교하며 이미 정렬된 부분에 레코드(A)를 삽입하는 방식."***

> 적은 비교와 많은 교환을 함.
>
> 이중 루프를 사용하기 때문에 O(N^2)의 성능을 가짐.
>
> 입력 자료에 따라 성능이 민감하게 변화함.<br>
> 이미 정렬된 경우 -> 매우 빠름.(최선의 경우)<br>
> 약간 정렬된 경우 -> 빠름.<br>
> 역순으로 정렬된 경우 -> 매우 느림.(최악의 경우)<br>
> 난수 배열인 경우 -> 선택 정렬보다 빠름.(평균적인 경우)

### 2) 장점

> 1. 데이터가 어느 정도 정렬되어 있는 경우 빠른 속도를 가짐.
> 2. 비교 조건을 적절히 작성한 경우 안정성 있음. (같은 것끼리는 교환하지 않아야 함.)

### 3) 단점

> 1. 크기가 큰 레코드를 정렬할 때 느림.[^3-1]

### 4) 예시
```c
/*
삽입 정렬로 정수 배열을 오름차순으로 정렬하는 함수.
*/
void insertion_sort(int a[], int size)
{
    int tmp, j;

    for(int i = 1; i < size; i++)
    {
        tmp = a[i];
        for(j = (i - 1); j >= 0; j--)
        {
            if(a[j] > tmp)
            {
                a[j + 1] = a[j];
            }
            else
            {
                break;
            }
        }
        a[j + 1] = tmp;
    }

    return;
}
```

<br>
<br>
<br>

# 4. 버블 정렬(bubble sort)

### 1) 버블 정렬(bubble sort)

>***"한쪽(a)에서부터 시작하여 각 레코드에 대해, 인접한 레코드끼리 서로 비교하며 a의 반대 방향으로 레코드를 보내 오른쪽에 정렬된 부분을 만드는 방식."***

> 이중 루프를 사용하기 때문에 O(N^2)의 성능을 가짐.
>
> 대부분의 데이터에 대해 대체로 느린 속도를 가지고 있음.<br>
> 이미 정렬된 경우 -> 비교적 빠름.(최선의 경우)<br>
> 역순으로 정렬된 경우 -> 매우 느림.(최악의 경우)

### 2) 장점

> 1. 비교 조건을 적절히 작성한 경우 안정성 있음. (같은 것끼리는 교환하지 않아야 함.)

### 3) 단점

> 1. 느림.[^4-1]

### 4) 예시
```c
/*
버블 정렬로 정수 배열을 오름차순으로 정렬하는 함수.
*/
void bubble_sort(int a[], int size)
{
    int tmp;
    for(int i = (size - 1); i > 0; i--)
    {
        for(int j = 0; j < i; j++)
        {
            if(a[j] > a[j + 1])
            {
                tmp = a[j];
                a[j] = a[j + 1];
                a[j + 1] = tmp;
            }
        }
    }
    return;
}
```

<br>
<br>
<br>

# 5. 쉘 정렬(shell sort)

### 1) 쉘 정렬(shell sort)

### 2) 장점

### 3) 단점

### 4) 예시

<br>
<br>
<br>

# 4. 버블 정렬(bubble sort)

### 1) 버블 정렬

### 2) 장점

### 3) 단점

### 4) 예시

<br>
<br>
<br>

# 4. 버블 정렬(bubble sort)

### 1) 버블 정렬

### 2) 장점

### 3) 단점

### 4) 예시

<br>
<br>
<br>

---

## 기타

- 반복문에서 *, []를 일반 변수로 대체하기

    반복문 내부 또는 조건에서 *, []는 일반 변수에 비해 속도가 느림.<br>
    값을 일반 변수에 넣어 대체하는 것이 유의미한 속도 향상을 만들어낼 수 있음.

[^1-1]: 1바이트씩 메모리에 접근하기 위한 것.
[^2-1]: 교환 횟수가 적기 때문.
[^2-2]: 동일한 키를 가진 레코드들은 정렬 후에 대체로 그 순서가 바뀜. 레코드끼리 순서를 마구 바꾸는 것을 생각하면 당연한 것.
[^2-3]: 비교에서 대부분의 시간을 쓰기 때문에 결과적으로 최선의 경우와 최악의 경우 각각의 실행 시간이 거의 동일함. 즉, 레코드의 종류에 비교적 무관한 실행 시간을 가짐.
[^3-1]: 레코드의 크기가 큰 경우는, 정렬 시 레코드 대신 인덱스 번호만을 옮기는 방식으로 성능을 개선할 수 있음.
[^4-1]: 비교와 교환이 너무 많음. 버블 정렬은 잘 사용되지 않는 알고리즘임.
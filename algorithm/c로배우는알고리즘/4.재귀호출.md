작성자: jhun0310 (wnsx0000@gmail.com)<br>
출처: 이재규. c로 배우는 알고리즘 1. 도서출판 세화, 1994.

22\. 11\. 27\. 최초 작성.<br>
22\. 12\. 11\. 작성 완료.

### 목차
1. 재귀 호출
2. 비재귀 함수로의 전환

<br>
<br>

# 1. 재귀 호출(recursion)

### 1) 재귀 호출(recursion)

> ***"자기 자신으로부터 이루어지는 함수 호출."***

> 재귀 호출을 하는 함수를 재귀 함수(recursive function)라고 함.<br>
> 모든 프로그래밍 언어가 재귀 호출을 지원하는 것은 아니지만, c는 지원함.
>
> 실행 시간[^1-1], 시스템의 위험성을 희생하고 소스의 간결함을 위해 사용함.<br>
> 최적화 단계에서 동일 기능의 비재귀 함수로 변환함.

### 2) 재귀 호출의 요건

> 1. 재귀 호출이 이루어질 때마다 문제는 작아져야 함.
> 2. 재귀 호출이 끝나는 종료 조건이 존재해야 함.

### 3) 재귀 호출의 종류

> 직접 재귀 호출 : 직접 자기 자신을 호출하는 경우.<br>
>
> 간접 재귀 호출 : 간접적으로 재귀 호출의 형태를 가지는 경우.<br>
> (2개의 함수가 서로를 재귀적으로 호출하는 경우 등.)

### 4) 재귀 호출 적용 양상

> 재귀 호출은 3가지 정도 형태로 적용됨.<br>
> 1. 문제의 크기를 조금씩 줄여가는 형태.(팩토리얼, 피보나치, 하노이의 탑 등.)
> 2. 문제의 크기를 양분하여 가는 형태.(퀵 정렬, 선분 그리기.)
> 3. 문제에 직접 접근하여 적용되는 형태.(tree traverse, uitility RFF.)

### 5) 재귀 나무(recursive tree)

> 재귀 호출이 2번 이상인 함수 내에서 재귀 호출을 분석하는 방법.<br>
> 나무 구조 도식을 작성하여 확인하는 것.

<img src="https://i.stack.imgur.com/QVSdv.png" width="350" height="150" />

<br>
<br>
<br>

# 2. 비재귀 함수로의 전환 [^2-1] [^2-2]

### 1) 재귀 호출이 하나인 경우

> 함수 내에 재귀 호출이 하나인 경우는 단순 반복문으로 전환함.

### 2) 재귀 호출이 둘인 경우

> 두 재귀 호출과 작업 코드의 위치에 따라 3가지 방식이 있음.<br>
> 3가지 방식 모두 스택을 활용함.<br>
> 비재귀 함수로 전환할 경우 아래의 형태를 참고하여 상황에 맞게 작성하면 됨.

> 1. 작업-호출-호출 순서
>
>    가장 간단하고 쉬운 방법.<br>
>    작업-호출-호출-.. 순서인 경우 재귀 호출이 3개 이상인 경우에도 동일한 형태로 만들 수 있음.(push()를 추가해 주기만 하면 됨. p.286 참고.)
>
>    ```c
>    //재귀 함수
>    recursive(인자 a)
>    {
>        if(종료 조건)
>        {
>            종료;
>        }
>        else
>        {
>            /* 작업 */
>            recursive(변경된 인자 1);
>            recursive(변경된 인자 2);
>        }
>    }
>    ```
>
>    ```c
>    //비재귀 함수로 전환한 형태
>    none_recursive(인자 a)
>    {
>        init_stack(); //스택 초기화
>        push(인자 a);
>        while(!stack_empty()) //스택이 빌 때까지
>        {
>            변수 = pop(); //작업할 내용 가져오기
>    
>            if(종료 조건) //본 재귀함수의 종료 조건
>            {
>                종료;
>            }
>            else
>            {
>                /* 작업 */
>                push(변경된 인자 2); //2를 먼저 넣어야 나중에 수행됨
>                push(변경된 인자 1);
>            }
>        }
>    }
>    ```
>
> 2. 호출-작업-호출 순서
>
>    ```c
>    //재귀 함수
>    recursive(인자 a)
>    {
>        if(종료 조건)
>        {
>            종료;
>        }
>        else
>        {
>            recursive(변경된 인자 1);
>            /* 작업 */
>            recursive(변경된 인자 2);
>        }
>    }
>    ```
>
>    ```c
>    none_recursive(인자 a)
>    {
>        init_stack(); //스택 초기화
>        while(1)
>        {
>            while(종료 조건)
>            {
>                push(인자 a);
>                인자 a = 변화된 인자 1; //먼저 처리할 방향부터 스택에 넣음
>            }
>
>            종료; //생략 가능. 왜 있는지 모르겠음. p.279 참고
>    
>            if(!stack_empty()) //스택이 비지 않은 경우
>            {
>                변수 = pop(); //작업할 내용 가져오기
>                /* 작업 */
>                인자 a = 변화된 인자 2;
>            }
>            else
>            {
>                break;
>            }
>        }
>    }
>    ```
>
> 3. 호출-호출-작업 순서
>
>    p.282 참고.

### 3) 그 외의 경우

> 새로운 접근 방법을 생각해 내는 수밖에 없음.

<br>
<br>
<br>

[^1-1]: 재귀 함수는 일반적으로 비재귀 함수에 비해 속도가 느림. 물론 재귀 함수가 더 빠른 경우도 있기 때문에, 매크로 등을 사용하는 등의 방법을 사용할 수 있음.
[^2-1]: 비재귀 함수로의 전환은 정해진 규칙이랄 것이 없기 때문에, 재귀 함수의 유형별로 처리 방식을 정리함.
[^2-2]: 당연하게도, 반드시 이 방법을 따라야 하는 것은 아님.
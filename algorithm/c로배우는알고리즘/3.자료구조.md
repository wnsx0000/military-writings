작성자: jhun0310 (wnsx0000@gmail.com)<br>
출처: 이재규. c로 배우는 알고리즘 1. 도서출판 세화, 1994.

22\. 10\. 22\. 최초 작성.

### 목차
1. 자료구조
2. 연결 리스트(linked list)
3. 스택

<br>
<br>

# 1. 자료구조

> ***"자료구조는 데이터의 모임, 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수/명령을 의미한다."***

> 각 자료구조는 규격화된 형태를 가지지만, 세부 사항은 작성자에게 달려 있음.</br>
> 즉, 책이나 필기 등에서 서술하는 형태를 반드시 따를 필요는 없음.

<br>
<br>
<br>

# 2. 연결 리스트(linked list)

연결 리스트는 node와 link(연결고리)로 구성됨.

연결 리스트의 장점
1. 동적인 자료 구조임.(프로그램 실행 중에 변경 가능, 메모리 절약)
2. 데이터의 재배열(삽입, 교체 등)이 간단함.

<br>

### 단순 연결 리스트(singly linked list)

> 단순 연결 리스트는 head/tail 포인터, 또는 head/tail node를 사용하는 등 여러 가지 방식으로 구현할 수 있음.[^2-1]<br>

> 본 교재에서 head/tail node를 사용하여 구현하는 방식.
>   1. head node는 데이터를 가지지 않고 다음 노드의 주소만을 가짐.<br>
>   2. tail node는 데이터를 가지지 않고 자신의 주소만을 가짐.[^2-2]

### 환형 연결 리스트(circluar linked list)

> ***"제일 마지막 node가 head node(처음 노드)를 가리키는 연결 리스트."***

> tail node라는 개념이 없고 처음과 마지막 노드가 이어져 있다는 것을 제외하면, 환형 연결 리스트는 단순 연결 리스트와 거의 유사함.<br>
> 즉, circular linked list는 단순하게 singly linked list를 만든 후 마지막 노드와 첫 노드를 이어줌으로서 쉽게 구현할 수 있음.

> head pointer 형식의 circluar linked list를 만드는 경우에 대한 팁.
>   1. 노드 삽입 시에는 head pointer가 가리키는 노드 뒤에 삽입하는 것이 간단함.<br>
>   2. 노드 삭제 시에는 head_pointer가 가리키는 노드 다음 노드를 삭제하는 것이 간단함.[^2-3]

<img src="https://static.packt-cdn.com/products/9781788623872/graphics/6879665f-8b34-4c46-a85f-2cdbaddc4e19.png" width="270" height="70" />

### 이중 연결 리스트(double linked list)

> ***"다음 노드를 가리키는 link와 이전 노드를 가리키는 link 모두를 가지고 있는 연결 리스트."***

> 앞/뒤 노드에 간단히 접근할 수 있는 연결 리스트.<br>
> 이중 연결 리스트는 문장을 저장하기에 적절하기 때문에[^2-4] 에디터나 워드프로세서에 주로 사용됨.

> 본 교재에서 head/tail node를 사용하여 구현하는 방식.<br>
>   1. head의 이전 방향 포인터는 head node 자신의 주소를 가짐.
>   2. tail의 다음 방향 포인터는 tail node 자신의 주소를 가짐.
>
> 당연하게도, 반드시 이런 방식으로 구현해야 하는 것은 아님.<br>
> head/tail의 주소 말고 NULL을 넣는 등으로 구현할 수도 있는 것.

<img src="https://th.bing.com/th/id/R.27a036b410f4b86886416a27136a4c76?rik=Z0V7dZkegNyyXA&riu=http%3a%2f%2fcfile26.uf.tistory.com%2fimage%2f234A964654605B1B331946&ehk=NzI6faB6ji9zAzv%2bltV974q7KS%2b%2byXm%2b1sIgyry5bUs%3d&risl=&pid=ImgRaw&r=0" width="290" height="80" />

<br>
<br>
<br>

# 3. 스택(Stack)

> LIFO 형식의 ADT.<br>
> Push와 Pop으로 조작함. (Push : 넣는 것, Pop : 빼는 것.)
>
> 스택은 임시 저장 장소로서 매우 다양한 곳에서 사용됨.<br>
> 시스템 내부에서 함수 등을 다룰 때, 산술식을 계산할 때, 재귀 호출을 비재귀 호출로 바꿀 때 등에 주로 사용됨.

### 배열로 스택 구현하기

> 배열과, 스택의 현재 작업 위치 인덱스를 저장할 변수 하나를 사용함.<br>
> Stack Overflow나 Stack Underflow가 일어나지 않도록 변수를 잘 처리해야 함.<br>
> (꽉 찬 경우와 텅 빈 경우의 처리에 유의해야 함.)
>
> 배열을 이용하는 방법의 특징.
>   1. 코드 작성이 용이해 프로그래밍에 부담이 없음.
>   2. 속도가 빠름.
>   3. link 등의 부가적 정보를 저장할 필요가 없음.
>   4. 메모리 사용이 정적이고, 또한 그 때문에 메모리가 낭비될 수 있음. 

### linked list로 스택 구현하기

> 1학년 2학기의 '프로그래밍응용및실습' 필기 참고.
>
> linked list를 사용하는 방법의 특징.
>   1. 포인터를 사용해야 하기에 프로그래밍에 부담이 있을 수 있음.
>   2. 메모리 사용이 동적임.

### 동적인 배열로 스택 구현하기

> 배열로 사용할 포인터를 선언하여 동적으로 메모리를 할당하여 사용하는 방법.<br>
> 할당한 메모리가 부족하거나 많이 남는 경우 메모리를 재할당함.
>
> 번거롭고 효율적이지 못한 방법일 수 있음.

<br>
<br>
<br>

# 4. 큐(Queue)

> FIFO 형식의 ADT.<br>
> Put과 Get으로 조작함. (Put : 넣는 것, Get : 빼는 것.)
>
> 큐는 키보드 버퍼, 마우스의 이벤트 큐 등 시스템 내부에서 자주 사용됨.

### 배열로 큐 구현하기

> 매번 한 칸씩 미는 방식이 있고, 원형 큐로 만드는 방식이 있음.<br>
> 일반 배열로 front와 rear를 사용해서는 큐를 구현할 수 없음.<br>
> (Put과 Get을 반복함에 따른 데이터 위치 변화를 생각해 보면 당연함.)

> 1. 매번 한 칸씩 미는 방식
>
>    Put하는 위치, Get하는 위치 둘 중에 하나를 고정하는 방식.<br>
>    배열과, Get으로 빼낼 정보가 있는 인덱스를 저장할 변수 하나를 사용함.<br>
>    고정한 위치에 맞춰 Put 또는 Get 시에 데이터를 한 칸씩 밀어야 함.
>
> 2. 원형 큐로 만드는 방식
> 
>    %로 인덱스를 다룸으로써 배열을 원형 배열처럼 사용할 수 있다는 것을 이용.[^4-1]<br>
>    배열과, Put과 Get의 위치를 나타내기 위해 front 변수와 rear 변수를 사용함.<br>
>    front/rear가 가리키는 것이 무엇인지, 완충지대[^4-2]를 설정할 것인지 등을 잘 정의하고 만들어야 착오가 없음.

### linked list로 큐 구현하기

> 1학년 2학기의 '프로그래밍응용및실습' 필기 참고.
>
> 개인적으로 큐는 head/tail pointer 형식의 linked list가 가장 편한 것 같음.

<br>
<br>
<br>

# 5. 트리(tree)

> node와 link로 이루어진 비선형적/2차원적 구조의 ADT.
>
> UNIX/LINUX의 디렉토리 구조, 대진표 등에서 사용됨.

### 트리 관련 용어들

> - node
>
>   linked list의 그것과 동일한 의미.<br>
>   Vertex라고도 함.<br>
>   트리의 최상위 노드는 root라고 함.<br>
>   자식이 없는 노드는 잎(leaf) 노드, 종료 노드, 또는 외부 노드라고 함.<br>
>   자식이 하나 이상인 노드는 비종료 노드, 또는 내부 노드라고 함.
>
> - link
>
>   linked list의 그것과 동일한 의미.<br>
>   edge라고도 함.
>
> - 경로(path)
>
>   특정 노드에서 다른 노드로 이동할 때의 경로. 노드들의 집합.<br>
>   root node로부터 다른 특정 노드로의 경로는 단 하나뿐임(절대경로).
>
> - 방향
>
>   관례적으로 root쪽이 위, 반대가 아래임.
>
> - 가족관계
>
>   특정 노드의 바로 상위 노드는 부모 노드, 특정 노드의 바로 하위 노드는 자식 노드라고 함.<br>
>   동일한 레벨의 노드들은 서로 형제 노드라고 함.
>
> - 레벨(level)
>
>   뿌리 노드로부터 얼마나 떨어져 있는지를 숫자로 나타낸 것.<br>
>   뿌리 노드는 레벨이 1임.<br>
>   나무의 노드들 중에 가장 높은 레벨을 해당 나무의 높이라고 함.
>
> - 경로의 길이
>
>   



[^2-1]: 연결 리스트에는 정형화된 형식 같은 것이 있는 것이 아님. 방식은 상황/입맛에 맞게 작성자가 선택하면 됨. 즉, head/tail node 등 대신에 head/tail 포인터를 사용해도 된다는 것.
[^2-2]: tail node가 NULL 대신 자신의 주소를 가진다면 반복문에서 조건 오류 등이 일어난 상황에서 무한 루프에 빠져 디버깅으로 원인을 파악하기 용이함.
[^2-3]: double circular linked list가 아니므로. 즉, 앞 노드를 참조하는 것이 까다롭기 때문.
[^2-4]: 이중 연결 리스트는 그 크기가 자주 변하고, 재배치되는 데이터를 다루기에 용이함.
[^4-1]: 인덱스에 1을 더하거나 뺀 값을 배열의 크기로 나눈 나머지를, 인덱스로 사용하는 것.
[^4-2]: 예외 처리를 위해 배열 중간에 데이터를 저장하지 않는 빈 칸 하나를 둔 것.
작성자: jhun0310 (wnsx0000@gmail.com)<br>
출처: 이재규. c로 배우는 알고리즘 1. 도서출판 세화, 1994.

22\. 10\. 22\. 최초 작성.<br>
22\. 11\. 20\. 작성 완료.

### 목차
1. 자료구조
2. 연결 리스트(linked list)
3. 스택(Stack)
4. 큐(Queue)
5. 트리(tree)

<br>
<br>

# 1. 자료구조

### 1) 자료구조

> ***"자료구조는 데이터의 모임, 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수/명령을 의미한다."***

> 각 자료구조는 규격화된 형태를 가지지만, 세부 사항은 작성자에게 달려 있음.</br>
> 즉, 책이나 필기 등에서 서술하는 형태를 반드시 따를 필요는 없음.

<br>
<br>
<br>

# 2. 연결 리스트(linked list)

### 1) 연결 리스트

> 연결 리스트는 node와 link(연결고리)로 구성됨.
> 
> 연결 리스트의 장점
> 1. 동적인 자료 구조임.(프로그램 실행 중에 변경 가능, 메모리 절약)
> 2. 데이터의 재배열(삽입, 교체 등)이 간단함.

### 2) 단순 연결 리스트(singly linked list)

> 단순 연결 리스트는 head/tail 포인터, 또는 head/tail node를 사용하는 등 여러 가지 방식으로 구현할 수 있음.[^2-1]<br>

> 본 교재에서 head/tail node를 사용하여 구현하는 방식.
>   1. head node는 데이터를 가지지 않고 다음 노드의 주소만을 가짐.<br>
>   2. tail node는 데이터를 가지지 않고 자신의 주소만을 가짐.[^2-2]

### 3) 환형 연결 리스트(circluar linked list)

> ***"제일 마지막 node가 head node(처음 노드)를 가리키는 연결 리스트."***

> tail node라는 개념이 없고 처음과 마지막 노드가 이어져 있다는 것을 제외하면, 환형 연결 리스트는 단순 연결 리스트와 거의 유사함.<br>
> 즉, circular linked list는 단순하게 singly linked list를 만든 후 마지막 노드와 첫 노드를 이어줌으로서 쉽게 구현할 수 있음.

> head pointer 형식의 circluar linked list를 만드는 경우에 대한 팁.
>   1. 노드 삽입 시에는 head pointer가 가리키는 노드 뒤에 삽입하는 것이 간단함.<br>
>   2. 노드 삭제 시에는 head_pointer가 가리키는 노드 다음 노드를 삭제하는 것이 간단함.[^2-3]

<img src="https://static.packt-cdn.com/products/9781788623872/graphics/6879665f-8b34-4c46-a85f-2cdbaddc4e19.png" width="270" height="70" />

### 4) 이중 연결 리스트(double linked list)

> ***"다음 노드를 가리키는 link와 이전 노드를 가리키는 link 모두를 가지고 있는 연결 리스트."***

> 앞/뒤 노드에 간단히 접근할 수 있는 연결 리스트.<br>
> 이중 연결 리스트는 문장을 저장하기에 적절하기 때문에[^2-4] 에디터나 워드프로세서에 주로 사용됨.

> 본 교재에서 head/tail node를 사용하여 구현하는 방식.<br>
>   1. head의 이전 방향 포인터는 head node 자신의 주소를 가짐.
>   2. tail의 다음 방향 포인터는 tail node 자신의 주소를 가짐.
>
> 당연하게도, 반드시 이런 방식으로 구현해야 하는 것은 아님.<br>
> head/tail의 주소 말고 NULL을 넣는 등으로 구현할 수도 있는 것.

<img src="https://th.bing.com/th/id/R.27a036b410f4b86886416a27136a4c76?rik=Z0V7dZkegNyyXA&riu=http%3a%2f%2fcfile26.uf.tistory.com%2fimage%2f234A964654605B1B331946&ehk=NzI6faB6ji9zAzv%2bltV974q7KS%2b%2byXm%2b1sIgyry5bUs%3d&risl=&pid=ImgRaw&r=0" width="290" height="80" />

<br>
<br>
<br>

# 3. 스택(Stack)

### 1) 스택(stack)

> LIFO 형식의 ADT.<br>
> Push와 Pop으로 조작함. (Push : 넣는 것, Pop : 빼는 것.)
> 
> 스택은 임시 저장 장소로서 매우 다양한 곳에서 사용됨.<br>
> 시스템 내부에서 함수 등을 다룰 때, 산술식을 계산할 때, 재귀 호출을 비재귀 호출로 바꿀 때 등에 주로 사용됨.
> 
> 스택을 사용하면 데이터를 원하는 시점에 사용할 수 있기 때문에, 임시로 데이터를 저장하거나 데이터를 분리할 때 유용함.(calc utitlity 참고.)

### 2) 배열로 스택 구현하기

> 배열과, 스택의 현재 작업 위치 인덱스를 저장할 변수 하나를 사용함.<br>
> Stack Overflow나 Stack Underflow가 일어나지 않도록 변수를 잘 처리해야 함.<br>
> (꽉 찬 경우와 텅 빈 경우의 처리에 유의해야 함.)
>
> 배열을 이용하는 방법의 특징.
>   1. 코드 작성이 용이해 프로그래밍에 부담이 없음.
>   2. 속도가 빠름.
>   3. link 등의 부가적 정보를 저장할 필요가 없음.
>   4. 메모리 사용이 정적이고, 또한 그 때문에 메모리가 낭비될 수 있음. 

### 3) linked list로 스택 구현하기

> 1학년 2학기의 '프로그래밍응용및실습' 필기 참고.
>
> linked list를 사용하는 방법의 특징.
>   1. 포인터를 사용해야 하기에 프로그래밍에 부담이 있을 수 있음.
>   2. 메모리 사용이 동적임.

### 4) 동적인 배열로 스택 구현하기

> 배열로 사용할 포인터를 선언하여 동적으로 메모리를 할당하여 사용하는 방법.<br>
> 할당한 메모리가 부족하거나 많이 남는 경우 메모리를 재할당함.
>
> 번거롭고 효율적이지 못한 방법일 수 있음.

<br>
<br>
<br>

# 4. 큐(Queue)

### 1) 큐(Queue)

> FIFO 형식의 ADT.<br>
> Put과 Get으로 조작함. (Put : 넣는 것, Get : 빼는 것.)
> 
> 큐는 키보드 버퍼, 마우스의 이벤트 큐 등 시스템 내부에서 자주 사용됨.

### 2) 배열로 큐 구현하기

> 매번 한 칸씩 미는 방식이 있고, 원형 큐로 만드는 방식이 있음.<br>
> 일반 배열로 front와 rear를 사용해서는 큐를 구현할 수 없음.<br>
> (Put과 Get을 반복함에 따른 데이터 위치 변화를 생각해 보면 당연함.)

> 1. 매번 한 칸씩 미는 방식
>
>    Put하는 위치, Get하는 위치 둘 중에 하나를 고정하는 방식.<br>
>    배열과, Get으로 빼낼 정보가 있는 인덱스를 저장할 변수 하나를 사용함.<br>
>    고정한 위치에 맞춰 Put 또는 Get 시에 데이터를 한 칸씩 밀어야 함.
>
> 2. 원형 큐로 만드는 방식
> 
>    %로 인덱스를 다룸으로써 배열을 원형 배열처럼 사용할 수 있다는 것을 이용.[^4-1]<br>
>    배열과, Put과 Get의 위치를 나타내기 위해 front 변수와 rear 변수를 사용함.<br>
>    front/rear가 가리키는 것이 무엇인지, 완충지대[^4-2]를 설정할 것인지 등을 잘 정의하고 만들어야 착오가 없음.

### 3) linked list로 큐 구현하기

> 1학년 2학기의 '프로그래밍응용및실습' 필기 참고.
>
> 개인적으로 큐는 head/tail pointer 형식의 linked list가 가장 편한 것 같음.

<br>
<br>
<br>

# 5. 트리(tree)

### 1) 트리(tree)

> node와 link로 이루어진 비선형적/2차원적 구조의 ADT.<br>
> 트리의 기본 동작은 알고리즘에 따라 다르게 정의됨.<br>
> 
> UNIX/LINUX의 디렉토리 구조, 대진표 등에서 사용됨.
> 
> 트리 자체를 스택에나 큐에 넣어 사용할 수도 있음.(parse tree 참고.)
> 
> 트리에 대해서는 4, 5장 등 이후의 내용을 더 참고하여 이해하자.<br>
> (4장의 힙 정렬과 5장의 이진 검색 트리, 기수 검색 등)

### 2) 트리 관련 용어들

> 이런 종류의 용어들은 완전히 통일된 것이 아니기 때문에 아래의 정의를 맹신해서는 안 됨.

> - node
>
>   linked list의 그것과 동일한 의미.<br>
>   Vertex라고도 함.<br>
>   트리의 최상위 노드는 root라고 함.<br>
>   자식이 없는 노드는 잎(leaf) 노드, 종료 노드, 또는 외부 노드라고 함.<br>
>   자식이 하나 이상인 노드는 비종료 노드, 또는 내부 노드라고 함.
>
> - link
>
>   linked list의 그것과 동일한 의미.<br>
>   edge라고도 함.
>
> - 경로(path)
>
>   특정 노드에서 다른 노드로 이동할 때의 경로. 노드들의 집합.<br>
>   root node로부터 다른 특정 노드로의 경로는 단 하나뿐임(절대경로).
>
> - 방향
>
>   관례적으로 root쪽이 위, 반대가 아래임.
>
> - 가족관계
>
>   특정 노드의 바로 상위 노드는 부모 노드, 특정 노드의 바로 하위 노드는 자식 노드라고 함.<br>
>   동일한 레벨의 노드들은 서로 형제 노드라고 함.
>
> - 레벨(level)
>
>   뿌리 노드로부터 얼마나 떨어져 있는지를 숫자로 나타낸 것.<br>
>   뿌리 노드는 레벨이 1임.(0으로 하기도 함.)<br>
>   나무의 노드들 중에 가장 높은 레벨을 해당 나무의 높이라고 함.(그냥 나무의 레벨이라고 하기도 함.)
>
> - 다중 트리(multiway tree)
>
>   모든 노드가 특정 정수 개 이하의 자손들만을 가지는 트리.<br>
>
> - 이진 트리(binary tree)
>
>   모든 노드가 자손을 2개 이하로 가지는 트리.<br>
>   실용적이고 구현이 간단해 가장 널리 쓰이는 트리임.<br>
>   이진 트리의 노드가 가지는 두 자식 노드는 각각 왼쪽 자식, 오른쪽 자식으로 부름.<br>
>
>   가장 마지막 레벨을 제외하고, 모든 레벨이 노드로 꽉 차 있는 이진 트리를 완전한 이진 트리(complete binary tree)라고 함.<br>
>   모든 레벨이 노드로 꽉 차 있는 이진 트리를 꽉 차 있는 이진 트리(full binary tree)라고 함.
>
>   꽉 차 있는 이진 트리의 레벨이 d이고 노드의 수를 N이라고 하면, ```2^(d-1) <= N <= 2^d - 1```이 성립함.[^5-1]

### 3) 트리의 성질

> 1. 한 노드에서 다른 노드로 가는 경로는 유일함.
>
> 2. N개의 노드를 가지는 트리는 N-1개의 link를 가짐.
>
> 3. 꽉 찬 이진 나무가 N개의 노드를 가진다면 그 높이는 log(밑:2)(진수:N) + 1의 정수부분임.
>
>    ```2^(d-1) <= N <= 2^d - 1```에 로그를 씌워서 증명할 수 있음.

### 4) 배열로 이진 트리 구현하기

> 5장의 힙 정렬 참고.
> 
> 배열을 이용하는 방법의 추가적(stack의 내용+) 특징.
> 1. link의 정보를 저장할 필요가 없는 완전히 균형잡힌 트리에 적합함.
>   
>    반대로 균형잡혀있지 않은 경우에는 비효율적임.
>

### 5) linked list로 이진 트리 구현하기

> link가 2개인 linked list인 것처럼 구현함.<br>
> 기본 동작에 대한 것은 4장의 힙 정렬과 5장의 이진 검색 트리, 기수 검색 참고.

### 6) linked list 이진 트리의 순회(traverse)

> 트리의 모든 노드들을 한 번씩 중복없이 순회하는 4가지의 나무타기(Tree traverse)가 있음.<br>
> 나무타기는 재귀적으로 정의됨.

> 1. 전위순회(Preorder traverse), 중위순회(Inorder traverse), 후위순회(Postorder traverse)
> 
>    전위순회(1 -> 2 -> 3) : root부터 출발하여 순회.<br>
>    중위순회(2 -> 1 -> 3) : 왼쪽 끝에서 출발하여 오른쪽 끝으로 순회. 중간에 root 거침.<br>
>    후위순회(2 -> 3 -> 1) : 왼쪽 끝에서 출발하여 오른쪽 끝으로 순회. 중간에 root 거치지 않음.
>
>    위 방법들은 3가지 동작을 가진 함수로 구현이 가능함.<br>
>    \1. node 방문 2. 왼쪽 자식으로 이동 3. 오른쪽 자식으로 이동.<br>
>
>    예시(전위순회)
>    ```c
>    void traverse(NODE *t)
>    {
>        if(t != NULL)
>        {
>            /* node 방문(작업 수행) */
>            traverse(t->left);
>            traverse(t->right);
>        }
>    }
>    ```
>
> 2. 층별순회(Level order traverse)
>
>    층별로 순회하는 방법.<br>
>    큐를 이용함.
>
>    예시
>    ```C
>    void traverse(NODE *t)
>    {
>        put(t);
>        while(!queue_empty())
>        {
>            t = get();
>            /* node 방문(작업 수행) */
>            if(t->left != NULL) put(t->left);
>            if(t->right != NULL) put(t->right);
>        }
>    }
>    ```

[^2-1]: 연결 리스트에는 정형화된 형식 같은 것이 있는 것이 아님. 방식은 상황/입맛에 맞게 작성자가 선택하면 됨. 즉, head/tail node 등 대신에 head/tail 포인터를 사용해도 된다는 것.
[^2-2]: tail node가 NULL 대신 자신의 주소를 가진다면 반복문에서 조건 오류 등이 일어난 상황에서 무한 루프에 빠져 디버깅으로 원인을 파악하기 용이함.
[^2-3]: double circular linked list가 아니므로. 즉, 앞 노드를 참조하는 것이 까다롭기 때문.
[^2-4]: 이중 연결 리스트는 그 크기가 자주 변하고, 재배치되는 데이터를 다루기에 용이함.
[^4-1]: 인덱스에 1을 더하거나 뺀 값을 배열의 크기로 나눈 나머지를, 인덱스로 사용하는 것.
[^4-2]: 예외 처리를 위해 배열 중간에 데이터를 저장하지 않는 빈 칸 하나를 둔 것.
[^5-1]: 책에는 이렇게 나와 있는데, 꽉 차 있는 이진 트리에 대한 식이 아니라 완전한 이진 트리에 대한 식인 것 같음.
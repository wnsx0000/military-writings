작성자: jhun0310 (wnsx0000@gmail.com)<br>
출처: 이재규. c로 배우는 알고리즘 1. 도서출판 세화, 1994.

22\. 10\. 22\. 최초 작성.

### 목차
1. 자료구조
2.

<br>
<br>

# 1. 자료구조

> ***"자료구조는 데이터의 모임, 데이터 간의 관계, 그리고 데이터에 적용할 수 있는 함수/명령을 의미한다."***

<br>
<br>
<br>

# 2. 연결 리스트(linked list)

연결 리스트는 node와 link(연결고리)로 구성됨.

연결 리스트의 장점
1. 동적인 자료 구조임.(프로그램 실행 중에 변경 가능, 메모리 절약)
2. 데이터의 재배열(삽입, 교체 등)이 간단함.

### 단순 연결 리스트(singly linked list)

> 단순 연결 리스트는 head/tail 포인터, 또는 head/tail node를 사용하는 등 여러 가지 방식으로 구현할 수 있음.[^2-1]<br>

> 본 교재에서 head/tail node를 사용하여 구현하는 방식.
>   1. head node는 데이터를 가지지 않고 다음 노드의 주소만을 가짐.<br>
>   2. tail node는 데이터를 가지지 않고 자신의 주소만을 가짐.[^2-2]

### 환형 연결 리스트(circluar linked list)

> ***"제일 마지막 node가 head node(처음 노드)를 가리키는 연결 리스트."***

> tail node라는 개념이 없고 처음과 마지막 노드가 이어져 있다는 것을 제외하면, 환형 연결 리스트는 단순 연결 리스트와 거의 유사함.<br>
> 즉, circular linked list는 단순하게 singly linked list를 만든 후 마지막 노드와 첫 노드를 이어줌으로서 쉽게 구현할 수 있음.

> head pointer 형식의 circluar linked list를 만드는 경우에 대한 팁.
>   1. 노드 삽입 시에는 head pointer가 가리키는 노드 뒤에 삽입하는 것이 간단함.<br>
>   2. 노드 삭제 시에는 head_pointer가 가리키는 노드 다음 노드를 삭제하는 것이 간단함.[^2-3]

<img src="https://static.packt-cdn.com/products/9781788623872/graphics/6879665f-8b34-4c46-a85f-2cdbaddc4e19.png" width="270" height="70" />

### 이중 연결 리스트(double linked list)

> ***"다음 노드를 가리키는 link와 이전 노드를 가리키는 link 모두를 가지고 있는 연결 리스트."***

> 앞/뒤 노드에 간단히 접근할 수 있는 연결 리스트.<br>
> 이중 연결 리스트는 문장을 저장하기에 적절하기 때문에[^2-4] 에디터나 워드프로세서에 주로 사용됨.

> 본 교재에서 head/tail node를 사용하여 구현하는 방식.<br>
>   1. head의 이전 방향 포인터는 head node 자신의 주소를 가짐.
>   2. tail의 다음 방향 포인터는 tail node 자신의 주소를 가짐.
>
> 당연하게도, 반드시 이런 방식으로 구현해야 하는 것은 아님.<br>
> head/tail의 주소 말고 NULL을 넣는 등으로 구현할 수도 있는 것.

<img src="https://th.bing.com/th/id/R.27a036b410f4b86886416a27136a4c76?rik=Z0V7dZkegNyyXA&riu=http%3a%2f%2fcfile26.uf.tistory.com%2fimage%2f234A964654605B1B331946&ehk=NzI6faB6ji9zAzv%2bltV974q7KS%2b%2byXm%2b1sIgyry5bUs%3d&risl=&pid=ImgRaw&r=0" width="290" height="80" />

<br>
<br>
<br>

# 3. 스택



[^2-1]: 연결 리스트에는 정형화된 형식 같은 것이 있는 것이 아님. 방식은 상황/입맛에 맞게 작성자가 선택하면 됨. 즉, head/tail node 등 대신에 head/tail 포인터를 사용해도 된다는 것.
[^2-2]: tail node가 NULL 대신 자신의 주소를 가진다면 반복문에서 조건 오류 등이 일어난 상황에서 무한 루프에 빠져 디버깅으로 원인을 파악하기 용이함.
[^2-3]: double circular linked list가 아니므로. 즉, 앞 노드를 참조하는 것이 까다롭기 때문.
[^2-4]: 이중 연결 리스트는 그 크기가 자주 변하고, 재배치되는 데이터를 다루기에 용이함.